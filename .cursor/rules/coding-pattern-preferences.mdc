---
description: 
globs: 
alwaysApply: true
---
# Coding Patterns and Development Rules

This document serves as an index for all development rules and patterns to be followed on this project.

## Development Workflow Rules

1. **Specification-First Development** - [specification-first.mdc](mdc:specification-first.mdc)
   - Create formal specifications for major features before implementation
   - Follow the structured template for all specifications
   - Use a checklist for tracking implementation progress

2. **Specification Tracking** - [specification-tracking.mdc](mdc:specification-tracking.mdc)
   - Always check if work is part of an existing specification
   - Update the specification checklist as tasks are completed
   - Document any deviations from the original plan within the specification

3. **Thorough Discovery and Verification** - [thorough-discovery.mdc](mdc:thorough-discovery.mdc)
   - Always verify if a file or component exists before creating a new one
   - Explicitly communicate uncertainty when expected files cannot be found
   - Wait for user confirmation before creating potentially duplicate code

## Technical Implementation Rules

### 1. Core Principles
* **Concise & Technical:** Write concise, technical responses with accurate TypeScript examples.  
* **Functional & Declarative:** Emphasize functional, declarative programming. Avoid classes.  
* **Iteration & Modularization:** Favor iteration and modularization over duplication. Always prefer simple solutions and check for existing implementations before adding new code.  
* **Descriptive Naming:** Use descriptive variable names—including auxiliary verbs (e.g., isLoading)—to improve code clarity.  
* **Directory Structure:** Use lowercase with dashes for directories (e.g., components/auth-wizard).  
* **Named Exports & RORO Pattern:** Favor named exports for components and apply the "Receive an Object, Return an Object" (RORO) pattern for function parameters and returns.

### 2. JavaScript/TypeScript Style
* **Function Syntax:** Write pure functions using the function keyword. Omit semicolons where Standard-TS allows.  
* **Type Safety:** Use TypeScript for all code. Prefer interfaces over types where appropriate. Avoid enums; use maps instead.  
* **File Structure:** Organize files as follows: Exported component, subcomponents, helpers, static content, and types.  
* **Conditional Statements:** Avoid unnecessary curly braces in conditional statements. For single-line statements in conditionals, omit curly braces. Use concise, one-line syntax for simple conditional statements (e.g., if (condition) doSomething()).
* **Type Precision:** Prefer changing the original type over type casting. If the original type is already in use and changing it would cause degradation, use an interface to adapt the type, in preference to type casting.

### 3. Error Handling and Validation
* **Prioritize Error Handling:** Prioritize error handling and edge cases.  
* **Early Returns:** Handle errors and edge cases at the beginning of functions using early returns to avoid deeply nested if statements.  
* **Happy Path Last:** Place the "happy path" last in the function for improved readability.  
* **Avoid Unnecessary else:** Avoid unnecessary else statements; use the if-return pattern instead.  
* **Guard Clauses:** Use guard clauses to handle preconditions and invalid states early.  
* **Logging & Messaging:** Implement proper error logging and user-friendly error messages.  
* **Custom Errors:** Consider using custom error types or error factories for consistent error handling.  
* **Error Modeling in Server Actions:** For expected errors in Server Actions, use useActionState and avoid try/catch. Return errors to the client.

### 4. Next.js App Router Conventions
* **React Server Components:** Use React Server Components as default for all components
* **Client Boundaries:** Carefully manage "use client" boundaries
* **Server Actions:** Implement form handling using server actions
* **State Management:** Rely on the Next.js App Router for state changes
* **Web Vitals:** Prioritize Web Vitals (LCP, CLS, FID)
* **Minimize 'use client':**
  * Prefer server components and Next.js SSR features
  * Use 'use client' only for Web API access in small components
  * Avoid using 'use client' for data fetching or state management

### 5. UI and Styling Conventions
* **Tailwind CSS:** Use Tailwind CSS for styling
* **Component Libraries:** Implement Shadcn UI, Radix UI, and Tailwind Aria for components
* **Responsive Design:** Follow responsive design principles with mobile-first approach
* **Image Optimization:** Optimize images: Use WebP format, include size data, and use lazy loading
* **Dynamic Loading:** Use dynamic loading (import()) for non-critical components
* **Content Placement:** Place static content and interfaces at the end of the file. Use content variables for static content outside render functions

### 6. Form Handling and Data Validation
* **Form Validation:** Use Zod for form validation
* **Form State:** Use useActionState with react-hook-form for form validation
* **Type-Safe Actions:** Use next-safe-action for all server actions:
  * Implement type-safe server actions with proper validation
  * Use the action function from next-safe-action
  * Define input schemas using Zod for robust type checking and validation
  * Handle errors gracefully and return appropriate responses
  * Use import type { ActionResponse } from '@/types/actions'
  * Ensure all server actions return the ActionResponse type
  * Implement consistent error handling and success responses using ActionResponse

### 7. Error Management
* **Error Boundaries:** Implement error boundaries using error.tsx and global-error.tsx to handle unexpected errors and provide a fallback UI
* **Service Errors:** Code in services/ dir always throw user-friendly errors that tanStackQuery can catch and show to the user
* **Suspense:** Wrap client components in Suspense with fallback

### 8. General Best Practices
* **Targeted Changes Only:** Make changes only when they are explicitly requested or when you are completely confident in their necessity and impact
* **Avoid Code Duplication:** Always check for similar functionality elsewhere in the codebase before writing new code
* **Clean Codebase:** Keep the overall codebase clean, well-organized, and free of redundant or legacy code
* **File Length Control:** Keep individual files within a 200–300 line limit. Refactor files that grow too large
* **Environment File Protection:** Never overwrite the .env file without first asking and confirming the change
* **Code for Environments:** Write code that takes into account the different environments: dev, test, and prod
* **No Mocking for Dev/Prod:** Never mock data for dev or prod environments
* **Prefer Simple Solutions:** Always favor the simplest solution that adequately addresses the problem

## Documentation Locations

- Specifications: `ai-docs/[feature-name]-specification.md`
- Architecture decisions: `ai-docs/architecture/`
- User documentation: `docs/`
